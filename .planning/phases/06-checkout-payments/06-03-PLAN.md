---
phase: 06-checkout-payments
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/stores/checkout.ts
  - apps/api/src/lib/vat.ts
  - apps/api/src/lib/shipping.ts
  - apps/api/src/routes/checkout/calculate.ts
  - apps/api/src/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Checkout state persists across page refreshes (Zustand persist)"
    - "VAT calculation shows 27% correctly"
    - "Shipping is free above 50,000 Ft threshold"
    - "Weight-based surcharge applies over 5kg"
    - "All calculations happen server-side (never in browser)"
  artifacts:
    - path: "apps/web/src/stores/checkout.ts"
      provides: "Multi-step checkout state management"
      contains: "persist"
    - path: "apps/api/src/lib/vat.ts"
      provides: "Hungarian VAT calculation"
      contains: "0.27"
    - path: "apps/api/src/lib/shipping.ts"
      provides: "Shipping cost calculation"
      contains: "freeShippingThreshold"
    - path: "apps/api/src/routes/checkout/calculate.ts"
      provides: "Order totals calculation endpoint"
      contains: "calculateOrderTotals"
  key_links:
    - from: "checkout.ts store"
      to: "localStorage"
      via: "Zustand persist middleware"
      pattern: "persist.*csz-checkout"
    - from: "calculate.ts"
      to: "vat.ts + shipping.ts"
      via: "imports"
      pattern: "import.*from.*lib/(vat|shipping)"
---

<objective>
Create checkout state management with Zustand persistence and server-side calculation endpoints for VAT, shipping, and order totals.

Purpose: Multi-step checkout requires persistent state across steps/refreshes. All pricing calculations MUST be server-side to prevent manipulation. This plan establishes the state management and calculation infrastructure.

Output: Checkout Zustand store, VAT/shipping calculation libraries, POST /checkout/calculate endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-checkout-payments/06-RESEARCH.md

Reference existing stores and API patterns:
@apps/web/src/stores/cart.ts
@apps/api/src/routes/cart/coupon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkout Zustand store</name>
  <files>apps/web/src/stores/checkout.ts</files>
  <action>
Create checkout state store at `apps/web/src/stores/checkout.ts`:

```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

type CheckoutStep = 'shipping' | 'billing' | 'summary' | 'payment';

interface CheckoutState {
  // Current step
  step: CheckoutStep;

  // Shipping address selection
  shippingAddressId: string | null;
  useNewShippingAddress: boolean;
  newShippingAddress: {
    recipientName: string;
    street: string;
    city: string;
    postalCode: string;
    country: string;
    phone: string;
  } | null;

  // Billing address
  useSameAsBilling: boolean;
  billingAddressId: string | null;
  useNewBillingAddress: boolean;
  newBillingAddress: {
    recipientName: string;
    street: string;
    city: string;
    postalCode: string;
    country: string;
    companyName?: string;
    vatNumber?: string;
  } | null;

  // B2B
  poReference: string;

  // Calculated totals (from server)
  calculatedTotals: {
    subtotal: number;
    discount: number;
    shipping: number;
    vatAmount: number;
    total: number;
  } | null;

  // Actions
  setStep: (step: CheckoutStep) => void;
  nextStep: () => void;
  prevStep: () => void;

  setShippingAddressId: (id: string | null) => void;
  setUseNewShippingAddress: (use: boolean) => void;
  setNewShippingAddress: (address: CheckoutState['newShippingAddress']) => void;

  setUseSameAsBilling: (same: boolean) => void;
  setBillingAddressId: (id: string | null) => void;
  setUseNewBillingAddress: (use: boolean) => void;
  setNewBillingAddress: (address: CheckoutState['newBillingAddress']) => void;

  setPoReference: (ref: string) => void;
  setCalculatedTotals: (totals: CheckoutState['calculatedTotals']) => void;

  reset: () => void;
}

const stepOrder: CheckoutStep[] = ['shipping', 'billing', 'summary', 'payment'];

const initialState = {
  step: 'shipping' as CheckoutStep,
  shippingAddressId: null,
  useNewShippingAddress: false,
  newShippingAddress: null,
  useSameAsBilling: true,
  billingAddressId: null,
  useNewBillingAddress: false,
  newBillingAddress: null,
  poReference: '',
  calculatedTotals: null,
};

export const useCheckoutStore = create<CheckoutState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setStep: (step) => set({ step }),

      nextStep: () => {
        const currentIndex = stepOrder.indexOf(get().step);
        if (currentIndex < stepOrder.length - 1) {
          set({ step: stepOrder[currentIndex + 1] });
        }
      },

      prevStep: () => {
        const currentIndex = stepOrder.indexOf(get().step);
        if (currentIndex > 0) {
          set({ step: stepOrder[currentIndex - 1] });
        }
      },

      setShippingAddressId: (id) => set({ shippingAddressId: id, useNewShippingAddress: false }),
      setUseNewShippingAddress: (use) => set({ useNewShippingAddress: use, shippingAddressId: null }),
      setNewShippingAddress: (address) => set({ newShippingAddress: address }),

      setUseSameAsBilling: (same) => set({ useSameAsBilling: same }),
      setBillingAddressId: (id) => set({ billingAddressId: id, useNewBillingAddress: false }),
      setUseNewBillingAddress: (use) => set({ useNewBillingAddress: use, billingAddressId: null }),
      setNewBillingAddress: (address) => set({ newBillingAddress: address }),

      setPoReference: (ref) => set({ poReference: ref }),
      setCalculatedTotals: (totals) => set({ calculatedTotals: totals }),

      reset: () => set(initialState),
    }),
    {
      name: 'csz-checkout',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        step: state.step,
        shippingAddressId: state.shippingAddressId,
        useNewShippingAddress: state.useNewShippingAddress,
        newShippingAddress: state.newShippingAddress,
        useSameAsBilling: state.useSameAsBilling,
        billingAddressId: state.billingAddressId,
        useNewBillingAddress: state.useNewBillingAddress,
        newBillingAddress: state.newBillingAddress,
        poReference: state.poReference,
        // Don't persist calculatedTotals - always fetch fresh from server
      }),
    }
  )
);

// Selectors
export const useCheckoutStep = () => useCheckoutStore((s) => s.step);
export const useShippingAddressId = () => useCheckoutStore((s) => s.shippingAddressId);
export const useCalculatedTotals = () => useCheckoutStore((s) => s.calculatedTotals);
```

This provides:
- Multi-step navigation (shipping -> billing -> summary -> payment)
- Shipping address selection (saved or new)
- Billing address handling (same as shipping or different)
- PO reference for B2B
- Server-calculated totals storage
- localStorage persistence under 'csz-checkout' key
- Reset function for clearing after order completion
  </action>
  <verify>
    - `pnpm --filter @csz/web build` compiles without errors
    - checkout.ts exports useCheckoutStore
    - Store uses persist middleware with 'csz-checkout' key
  </verify>
  <done>Checkout Zustand store created with multi-step state and persistence</done>
</task>

<task type="auto">
  <name>Task 2: Create VAT and shipping calculation libraries</name>
  <files>
    apps/api/src/lib/vat.ts
    apps/api/src/lib/shipping.ts
  </files>
  <action>
Create VAT calculation library at `apps/api/src/lib/vat.ts`:

```typescript
/**
 * Hungarian VAT calculation utilities
 * VAT rate: 27% (fixed by Hungarian law)
 *
 * Hungarian e-commerce displays gross prices (VAT included).
 * These utilities extract the VAT breakdown from gross prices.
 */

const HUNGARIAN_VAT_RATE = 0.27;

export interface VatBreakdown {
  netPrice: number;    // Price without VAT
  vatAmount: number;   // VAT amount
  grossPrice: number;  // Price with VAT (what customer pays)
}

/**
 * Calculate VAT breakdown from gross price (price includes VAT).
 * Uses integer math to avoid floating point issues with HUF.
 */
export function calculateVatFromGross(grossPrice: number): VatBreakdown {
  // grossPrice = netPrice * (1 + VAT_RATE)
  // netPrice = grossPrice / (1 + VAT_RATE)
  const netPrice = Math.round(grossPrice / (1 + HUNGARIAN_VAT_RATE));
  const vatAmount = grossPrice - netPrice;

  return {
    netPrice,
    vatAmount,
    grossPrice,
  };
}

/**
 * Calculate VAT amount to add to net price.
 */
export function calculateVatAmount(netPrice: number): number {
  return Math.round(netPrice * HUNGARIAN_VAT_RATE);
}

export const VAT_RATE = HUNGARIAN_VAT_RATE;
```

Create shipping calculation library at `apps/api/src/lib/shipping.ts`:

```typescript
/**
 * Shipping cost calculation for Hungary
 *
 * Rules:
 * - Base flat rate: 1,990 Ft
 * - Free shipping over 50,000 Ft
 * - Weight surcharge: +500 Ft per kg over 5kg
 * - Shipping restricted to Hungary only
 */

export interface ShippingConfig {
  baseRate: number;              // Base flat rate in HUF
  weightThreshold: number;       // Weight threshold in kg
  weightSurchargePerKg: number;  // Additional charge per kg over threshold
  freeShippingThreshold: number; // Order total for free shipping
}

const config: ShippingConfig = {
  baseRate: 1990,               // 1,990 Ft base
  weightThreshold: 5,           // Over 5kg
  weightSurchargePerKg: 500,    // +500 Ft per kg over 5kg
  freeShippingThreshold: 50000, // Free over 50,000 Ft
};

/**
 * Calculate shipping cost based on order subtotal and total weight.
 * @param totalWeight - Total weight in kg (sum of all items)
 * @param orderSubtotal - Order subtotal in HUF (before shipping)
 * @returns Shipping cost in HUF
 */
export function calculateShipping(
  totalWeight: number,
  orderSubtotal: number
): number {
  // Free shipping over threshold
  if (orderSubtotal >= config.freeShippingThreshold) {
    return 0;
  }

  // Base rate
  let shipping = config.baseRate;

  // Weight surcharge
  if (totalWeight > config.weightThreshold) {
    const extraKg = Math.ceil(totalWeight - config.weightThreshold);
    shipping += extraKg * config.weightSurchargePerKg;
  }

  return shipping;
}

/**
 * Check if shipping address is valid (Hungary only).
 * Accepts various spellings of Hungary.
 */
export function isValidShippingCountry(country: string): boolean {
  const normalized = country.toLowerCase().trim();
  return (
    normalized === 'magyarorszag' ||
    normalized === 'magyarorsz√°g' ||
    normalized === 'hungary' ||
    normalized === 'hu'
  );
}

/**
 * Get free shipping threshold for display.
 */
export function getFreeShippingThreshold(): number {
  return config.freeShippingThreshold;
}

export { config as shippingConfig };
```
  </action>
  <verify>
    - `pnpm --filter @csz/api build` compiles without errors
    - vat.ts exports calculateVatFromGross, VAT_RATE
    - shipping.ts exports calculateShipping, isValidShippingCountry
  </verify>
  <done>VAT (27%) and shipping calculation libraries created</done>
</task>

<task type="auto">
  <name>Task 3: Create calculate totals API endpoint</name>
  <files>
    apps/api/src/routes/checkout/calculate.ts
    apps/api/src/index.ts
  </files>
  <action>
Create calculate endpoint at `apps/api/src/routes/checkout/calculate.ts`:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import qs from 'qs';
import { calculateVatFromGross } from '../../lib/vat.js';
import { calculateShipping, isValidShippingCountry } from '../../lib/shipping.js';

const STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';

interface LineItem {
  productId: string;      // documentId
  variantId?: string;     // documentId
  quantity: number;
}

interface CalculateBody {
  lineItems: LineItem[];
  couponCode?: string;
  shippingCountry: string;
}

interface CalculateResponse {
  subtotal: number;
  discount: number;
  shipping: number;
  netTotal: number;
  vatAmount: number;
  total: number;
  freeShippingThreshold: number;
  couponApplied: boolean;
  couponError?: string;
}

async function fetchProductPrices(lineItems: LineItem[]): Promise<Map<string, { price: number; weight: number }>> {
  const prices = new Map<string, { price: number; weight: number }>();

  // Fetch products
  const productIds = [...new Set(lineItems.filter(li => !li.variantId).map(li => li.productId))];
  if (productIds.length > 0) {
    const query = qs.stringify({
      filters: { documentId: { $in: productIds } },
      fields: ['documentId', 'basePrice', 'weight'],
    });

    const res = await fetch(`${STRAPI_URL}/api/products?${query}`);
    if (res.ok) {
      const json = await res.json();
      for (const product of json.data || []) {
        prices.set(product.documentId, {
          price: product.basePrice,
          weight: product.weight || 0,
        });
      }
    }
  }

  // Fetch variants
  const variantIds = [...new Set(lineItems.filter(li => li.variantId).map(li => li.variantId!))];
  if (variantIds.length > 0) {
    const query = qs.stringify({
      filters: { documentId: { $in: variantIds } },
      fields: ['documentId', 'price', 'weight'],
    });

    const res = await fetch(`${STRAPI_URL}/api/product-variants?${query}`);
    if (res.ok) {
      const json = await res.json();
      for (const variant of json.data || []) {
        prices.set(variant.documentId, {
          price: variant.price,
          weight: variant.weight || 0,
        });
      }
    }
  }

  return prices;
}

async function validateCoupon(
  code: string,
  subtotal: number
): Promise<{ valid: boolean; discount: number; error?: string }> {
  const query = qs.stringify({
    filters: { code: { $eqi: code } },
  });

  const res = await fetch(`${STRAPI_URL}/api/coupons?${query}`);
  if (!res.ok) {
    return { valid: false, discount: 0, error: 'Kupon ellenorzese sikertelen' };
  }

  const json = await res.json();
  const coupons = json.data || [];

  if (coupons.length === 0) {
    return { valid: false, discount: 0, error: 'Ervenytelen kuponkod' };
  }

  const coupon = coupons[0];

  // Check if active
  if (!coupon.isActive) {
    return { valid: false, discount: 0, error: 'Ez a kupon mar nem aktiv' };
  }

  // Check dates
  const now = new Date();
  if (coupon.validFrom && new Date(coupon.validFrom) > now) {
    return { valid: false, discount: 0, error: 'Ez a kupon meg nem ervenyes' };
  }
  if (coupon.validUntil && new Date(coupon.validUntil) < now) {
    return { valid: false, discount: 0, error: 'Ez a kupon mar lejart' };
  }

  // Check usage limit
  if (coupon.maxUses && coupon.usedCount >= coupon.maxUses) {
    return { valid: false, discount: 0, error: 'Ez a kupon elerte a felhasznalasi limitet' };
  }

  // Check minimum order
  if (coupon.minOrderValue && subtotal < coupon.minOrderValue) {
    return {
      valid: false,
      discount: 0,
      error: `Minimum rendelesi ertek: ${coupon.minOrderValue.toLocaleString('hu-HU')} Ft`
    };
  }

  // Calculate discount
  let discount = 0;
  if (coupon.discountType === 'percentage') {
    discount = Math.round(subtotal * (coupon.discountValue / 100));
    if (coupon.maxDiscount) {
      discount = Math.min(discount, coupon.maxDiscount);
    }
  } else {
    discount = coupon.discountValue;
  }

  // Cap at subtotal
  discount = Math.min(discount, subtotal);

  return { valid: true, discount };
}

export const calculateRoutes: FastifyPluginAsync = async (fastify) => {
  // POST /checkout/calculate - Calculate order totals
  fastify.post<{ Body: CalculateBody }>('/checkout/calculate', async (request, reply) => {
    const { lineItems, couponCode, shippingCountry } = request.body;

    // Validate shipping country
    if (!isValidShippingCountry(shippingCountry)) {
      return reply.status(400).send({
        error: 'Sajnos csak Magyarorszagra szallitunk',
      });
    }

    if (!lineItems || lineItems.length === 0) {
      return reply.status(400).send({
        error: 'A kosar ures',
      });
    }

    // Fetch current prices from database (NEVER trust client prices)
    const prices = await fetchProductPrices(lineItems);

    // Calculate subtotal and total weight
    let subtotal = 0;
    let totalWeight = 0;

    for (const item of lineItems) {
      const key = item.variantId || item.productId;
      const priceInfo = prices.get(key);

      if (!priceInfo) {
        return reply.status(400).send({
          error: `Termek nem talalhato: ${key}`,
        });
      }

      subtotal += priceInfo.price * item.quantity;
      totalWeight += priceInfo.weight * item.quantity;
    }

    // Validate and apply coupon
    let discount = 0;
    let couponApplied = false;
    let couponError: string | undefined;

    if (couponCode) {
      const couponResult = await validateCoupon(couponCode, subtotal);
      if (couponResult.valid) {
        discount = couponResult.discount;
        couponApplied = true;
      } else {
        couponError = couponResult.error;
      }
    }

    // Calculate shipping
    const discountedSubtotal = subtotal - discount;
    const shipping = calculateShipping(totalWeight, discountedSubtotal);

    // Calculate total and VAT
    const total = discountedSubtotal + shipping;
    const { netPrice, vatAmount } = calculateVatFromGross(total);

    const response: CalculateResponse = {
      subtotal,
      discount,
      shipping,
      netTotal: netPrice,
      vatAmount,
      total,
      freeShippingThreshold: 50000,
      couponApplied,
      couponError,
    };

    return reply.send(response);
  });
};
```

Update `apps/api/src/index.ts` to register the calculate routes:

```typescript
// Add import at top
import { calculateRoutes } from './routes/checkout/calculate.js';

// Register checkout routes (add after webhookRoutes)
await fastify.register(calculateRoutes, { prefix: '/checkout' });
```

The endpoint will be at `POST /checkout/calculate`.
  </action>
  <verify>
    - `pnpm --filter @csz/api build` compiles without errors
    - calculate.ts exports calculateRoutes
    - index.ts imports and registers calculateRoutes
    - API starts without errors: `cd apps/api && pnpm dev`
  </verify>
  <done>Calculate totals endpoint created with server-side VAT, shipping, and coupon validation</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Web build: `pnpm --filter @csz/web build` succeeds
2. API build: `pnpm --filter @csz/api build` succeeds
3. API starts: `cd apps/api && pnpm dev`

Test calculate endpoint:
```bash
curl -X POST http://localhost:4000/checkout/calculate \
  -H "Content-Type: application/json" \
  -d '{
    "lineItems": [{"productId": "abc123", "quantity": 2}],
    "shippingCountry": "Magyarorszag"
  }'
# Returns calculated totals with VAT breakdown
```

Test shipping country validation:
```bash
curl -X POST http://localhost:4000/checkout/calculate \
  -H "Content-Type: application/json" \
  -d '{
    "lineItems": [{"productId": "abc123", "quantity": 1}],
    "shippingCountry": "Germany"
  }'
# Returns 400: "Sajnos csak Magyarorszagra szallitunk"
```
</verification>

<success_criteria>
- Checkout store persists state to localStorage under 'csz-checkout'
- VAT calculation shows 27% correctly
- Shipping free above 50,000 Ft
- Weight surcharge applies over 5kg
- Calculate endpoint validates country (Hungary only)
- Calculate endpoint fetches current prices from database
- All calculations are server-side
</success_criteria>

<output>
After completion, create `.planning/phases/06-checkout-payments/06-03-SUMMARY.md`
</output>
