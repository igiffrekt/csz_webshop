---
phase: 06-checkout-payments
plan: 06
type: execute
wave: 3
depends_on: [06-01, 06-02, 06-03, 06-04, 06-05]
files_modified:
  - apps/web/package.json
  - apps/api/src/routes/checkout/create-session.ts
  - apps/api/src/index.ts
  - apps/web/src/app/[locale]/penztar/steps/PaymentStep.tsx
  - apps/web/src/app/[locale]/penztar/CheckoutClient.tsx
autonomous: false
user_setup:
  - service: stripe
    why: "Client-side payment form"
    env_vars:
      - name: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
        source: "Stripe Dashboard > Developers > API keys > Publishable key"

must_haves:
  truths:
    - "User can pay with credit/debit card"
    - "User can pay with Apple Pay (where supported)"
    - "User can pay with Google Pay (where supported)"
    - "Order is created in Strapi before payment"
    - "Stripe session references order ID for webhook processing"
  artifacts:
    - path: "apps/api/src/routes/checkout/create-session.ts"
      provides: "Create Stripe Checkout Session endpoint"
      contains: "stripe.checkout.sessions.create"
    - path: "apps/web/src/app/[locale]/penztar/steps/PaymentStep.tsx"
      provides: "Stripe Embedded Checkout component"
      contains: "EmbeddedCheckout"
  key_links:
    - from: "PaymentStep.tsx"
      to: "@stripe/react-stripe-js"
      via: "EmbeddedCheckoutProvider"
      pattern: "EmbeddedCheckout"
    - from: "create-session.ts"
      to: "Strapi Order API"
      via: "POST to create order"
      pattern: "strapi.*orders"
---

<objective>
Create the Stripe payment integration with Embedded Checkout for card payments including Apple Pay and Google Pay.

Purpose: PAY-01 (card payments), PAY-02 (Apple Pay), PAY-03 (Google Pay) all use Stripe's Embedded Checkout which handles payment method display automatically. The create-session endpoint creates the order in Strapi first, then creates a Stripe Checkout Session.

Output: Create session API endpoint, PaymentStep component with Stripe Embedded Checkout.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-checkout-payments/06-RESEARCH.md

Reference existing patterns:
@apps/api/src/lib/stripe.ts (created in 06-02)
@apps/api/src/routes/checkout/calculate.ts (created in 06-03)
@apps/web/src/stores/checkout.ts (created in 06-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Stripe React SDK</name>
  <files>apps/web/package.json</files>
  <action>
Install Stripe client-side packages:

```bash
cd apps/web
pnpm add @stripe/stripe-js @stripe/react-stripe-js
```

This adds:
- `@stripe/stripe-js` - Stripe.js loader (loads from Stripe CDN)
- `@stripe/react-stripe-js` - React components including EmbeddedCheckout

Add NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY to .env.example:
```
# Stripe (client-side)
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
```
  </action>
  <verify>
    - @stripe/stripe-js and @stripe/react-stripe-js in apps/web/package.json
    - `pnpm install` succeeds
  </verify>
  <done>Stripe React SDK installed</done>
</task>

<task type="auto">
  <name>Task 2: Create checkout session endpoint</name>
  <files>
    apps/api/src/routes/checkout/create-session.ts
    apps/api/src/index.ts
  </files>
  <action>
Create create-session endpoint at `apps/api/src/routes/checkout/create-session.ts`:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import { stripe } from '../../lib/stripe.js';
import { calculateVatFromGross } from '../../lib/vat.js';
import { calculateShipping } from '../../lib/shipping.js';
import qs from 'qs';

const STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';
const STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;
const FRONTEND_URL = process.env.FRONTEND_URL || 'http://localhost:3000';

interface LineItemInput {
  productId: string;
  variantId?: string;
  quantity: number;
  name: string;
  variantName?: string;
  sku: string;
  price: number;
}

interface AddressInput {
  recipientName: string;
  street: string;
  city: string;
  postalCode: string;
  country: string;
  phone?: string;
  companyName?: string;
  vatNumber?: string;
}

interface CreateSessionBody {
  lineItems: LineItemInput[];
  shippingAddress: AddressInput;
  billingAddress?: AddressInput;
  couponCode?: string;
  poReference?: string;
  userId: number;
}

async function generateOrderNumber(): Promise<string> {
  const year = new Date().getFullYear();
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `CSZ-${year}-${timestamp}${random}`;
}

async function fetchProductPrices(lineItems: LineItemInput[]): Promise<Map<string, { price: number; weight: number }>> {
  const prices = new Map<string, { price: number; weight: number }>();

  const productIds = [...new Set(lineItems.filter(li => !li.variantId).map(li => li.productId))];
  if (productIds.length > 0) {
    const query = qs.stringify({
      filters: { documentId: { $in: productIds } },
      fields: ['documentId', 'basePrice', 'weight'],
    });

    const res = await fetch(`${STRAPI_URL}/api/products?${query}`);
    if (res.ok) {
      const json = await res.json();
      for (const product of json.data || []) {
        prices.set(product.documentId, {
          price: product.basePrice,
          weight: product.weight || 0,
        });
      }
    }
  }

  const variantIds = [...new Set(lineItems.filter(li => li.variantId).map(li => li.variantId!))];
  if (variantIds.length > 0) {
    const query = qs.stringify({
      filters: { documentId: { $in: variantIds } },
      fields: ['documentId', 'price', 'weight'],
    });

    const res = await fetch(`${STRAPI_URL}/api/product-variants?${query}`);
    if (res.ok) {
      const json = await res.json();
      for (const variant of json.data || []) {
        prices.set(variant.documentId, {
          price: variant.price,
          weight: variant.weight || 0,
        });
      }
    }
  }

  return prices;
}

async function validateAndCalculateCoupon(
  code: string,
  subtotal: number
): Promise<{ valid: boolean; discount: number }> {
  const query = qs.stringify({
    filters: { code: { $eqi: code } },
  });

  const res = await fetch(`${STRAPI_URL}/api/coupons?${query}`);
  if (!res.ok) return { valid: false, discount: 0 };

  const json = await res.json();
  const coupons = json.data || [];
  if (coupons.length === 0) return { valid: false, discount: 0 };

  const coupon = coupons[0];

  if (!coupon.isActive) return { valid: false, discount: 0 };

  const now = new Date();
  if (coupon.validFrom && new Date(coupon.validFrom) > now) return { valid: false, discount: 0 };
  if (coupon.validUntil && new Date(coupon.validUntil) < now) return { valid: false, discount: 0 };
  if (coupon.maxUses && coupon.usedCount >= coupon.maxUses) return { valid: false, discount: 0 };
  if (coupon.minOrderValue && subtotal < coupon.minOrderValue) return { valid: false, discount: 0 };

  let discount = 0;
  if (coupon.discountType === 'percentage') {
    discount = Math.round(subtotal * (coupon.discountValue / 100));
    if (coupon.maxDiscount) discount = Math.min(discount, coupon.maxDiscount);
  } else {
    discount = coupon.discountValue;
  }

  return { valid: true, discount: Math.min(discount, subtotal) };
}

async function createOrder(data: {
  orderNumber: string;
  userId: number;
  subtotal: number;
  discount: number;
  shipping: number;
  vatAmount: number;
  total: number;
  shippingAddress: AddressInput;
  billingAddress?: AddressInput;
  lineItems: Array<{
    productId: string;
    variantId?: string;
    name: string;
    variantName?: string;
    sku: string;
    price: number;
    quantity: number;
    total: number;
  }>;
  couponCode?: string;
  couponDiscount?: number;
  poReference?: string;
  stripeSessionId?: string;
}): Promise<{ documentId: string; orderNumber: string }> {
  const response = await fetch(`${STRAPI_URL}/api/orders`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${STRAPI_API_TOKEN}`,
    },
    body: JSON.stringify({
      data: {
        orderNumber: data.orderNumber,
        status: 'pending',
        user: data.userId,
        subtotal: data.subtotal,
        discount: data.discount,
        shipping: data.shipping,
        vatAmount: data.vatAmount,
        total: data.total,
        shippingAddress: data.shippingAddress,
        billingAddress: data.billingAddress || data.shippingAddress,
        lineItems: data.lineItems,
        couponCode: data.couponCode,
        couponDiscount: data.couponDiscount,
        poReference: data.poReference,
        stripeSessionId: data.stripeSessionId,
      },
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Failed to create order: ${JSON.stringify(error)}`);
  }

  const json = await response.json();
  return {
    documentId: json.data.documentId,
    orderNumber: json.data.orderNumber,
  };
}

export const createSessionRoutes: FastifyPluginAsync = async (fastify) => {
  // POST /checkout/create-session - Create Stripe Checkout Session
  fastify.post<{ Body: CreateSessionBody }>('/checkout/create-session', async (request, reply) => {
    const {
      lineItems,
      shippingAddress,
      billingAddress,
      couponCode,
      poReference,
      userId,
    } = request.body;

    // Validate request
    if (!lineItems || lineItems.length === 0) {
      return reply.status(400).send({ error: 'A kosar ures' });
    }

    if (!shippingAddress) {
      return reply.status(400).send({ error: 'Szallitasi cim szukseges' });
    }

    if (!userId) {
      return reply.status(400).send({ error: 'Felhasznalo azonosito szukseges' });
    }

    try {
      // Fetch current prices from database (NEVER trust client prices)
      const prices = await fetchProductPrices(lineItems);

      // Calculate totals
      let subtotal = 0;
      let totalWeight = 0;
      const verifiedLineItems: Array<{
        productId: string;
        variantId?: string;
        name: string;
        variantName?: string;
        sku: string;
        price: number;
        quantity: number;
        total: number;
      }> = [];

      for (const item of lineItems) {
        const key = item.variantId || item.productId;
        const priceInfo = prices.get(key);

        if (!priceInfo) {
          return reply.status(400).send({ error: `Termek nem talalhato: ${item.name}` });
        }

        subtotal += priceInfo.price * item.quantity;
        totalWeight += priceInfo.weight * item.quantity;

        verifiedLineItems.push({
          productId: item.productId,
          variantId: item.variantId,
          name: item.name,
          variantName: item.variantName,
          sku: item.sku,
          price: priceInfo.price, // Use server price
          quantity: item.quantity,
          total: priceInfo.price * item.quantity,
        });
      }

      // Apply coupon
      let discount = 0;
      if (couponCode) {
        const couponResult = await validateAndCalculateCoupon(couponCode, subtotal);
        if (couponResult.valid) {
          discount = couponResult.discount;
        }
      }

      // Calculate shipping
      const discountedSubtotal = subtotal - discount;
      const shipping = calculateShipping(totalWeight, discountedSubtotal);

      // Calculate VAT and total
      const total = discountedSubtotal + shipping;
      const { vatAmount } = calculateVatFromGross(total);

      // Generate order number
      const orderNumber = await generateOrderNumber();

      // Create order in Strapi FIRST (before Stripe session)
      const order = await createOrder({
        orderNumber,
        userId,
        subtotal,
        discount,
        shipping,
        vatAmount,
        total,
        shippingAddress,
        billingAddress,
        lineItems: verifiedLineItems,
        couponCode: discount > 0 ? couponCode : undefined,
        couponDiscount: discount > 0 ? discount : undefined,
        poReference,
      });

      // Create Stripe line items (HUF is zero-decimal currency)
      const stripeLineItems = verifiedLineItems.map((item) => ({
        price_data: {
          currency: 'huf',
          product_data: {
            name: item.variantName ? `${item.name} - ${item.variantName}` : item.name,
          },
          unit_amount: item.price, // HUF - no multiplication needed
        },
        quantity: item.quantity,
      }));

      // Add shipping as a line item if not free
      if (shipping > 0) {
        stripeLineItems.push({
          price_data: {
            currency: 'huf',
            product_data: {
              name: 'Szallitasi dij',
            },
            unit_amount: shipping,
          },
          quantity: 1,
        });
      }

      // Add discount as a coupon if applicable
      let discounts: Array<{ coupon: string }> | undefined;
      if (discount > 0) {
        // Create a one-time coupon for this checkout
        const stripeCoupon = await stripe.coupons.create({
          amount_off: discount,
          currency: 'huf',
          duration: 'once',
          name: couponCode || 'Kedvezmeny',
        });
        discounts = [{ coupon: stripeCoupon.id }];
      }

      // Create Stripe Checkout Session
      const session = await stripe.checkout.sessions.create({
        ui_mode: 'embedded',
        mode: 'payment',
        currency: 'huf',
        locale: 'hu',
        line_items: stripeLineItems,
        discounts,
        metadata: {
          order_id: order.documentId,
          order_number: order.orderNumber,
          po_reference: poReference || '',
        },
        return_url: `${FRONTEND_URL}/hu/penztar/siker?session_id={CHECKOUT_SESSION_ID}`,
      });

      // Update order with Stripe session ID
      await fetch(`${STRAPI_URL}/api/orders/${order.documentId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${STRAPI_API_TOKEN}`,
        },
        body: JSON.stringify({
          data: { stripeSessionId: session.id },
        }),
      });

      return reply.send({
        clientSecret: session.client_secret,
        orderId: order.documentId,
        orderNumber: order.orderNumber,
      });
    } catch (error) {
      fastify.log.error(error, 'Failed to create checkout session');
      return reply.status(500).send({
        error: 'Hiba tortent a fizetes inditasakor',
      });
    }
  });
};
```

Update `apps/api/src/index.ts` to register the create-session routes:

```typescript
// Add import at top
import { createSessionRoutes } from './routes/checkout/create-session.js';

// Register create-session routes (after calculateRoutes)
await fastify.register(createSessionRoutes, { prefix: '/checkout' });
```
  </action>
  <verify>
    - create-session.ts creates order in Strapi before Stripe session
    - create-session.ts uses server-side prices (not client-provided)
    - create-session.ts stores order_id in Stripe metadata
    - `pnpm --filter @csz/api build` compiles
    - API starts: `cd apps/api && pnpm dev`
  </verify>
  <done>Create session endpoint created with order-first flow</done>
</task>

<task type="auto">
  <name>Task 3: Create payment step with Stripe Embedded Checkout</name>
  <files>
    apps/web/src/app/[locale]/penztar/steps/PaymentStep.tsx
    apps/web/src/app/[locale]/penztar/CheckoutClient.tsx
  </files>
  <action>
Create payment step at `apps/web/src/app/[locale]/penztar/steps/PaymentStep.tsx`:

```typescript
'use client';

import { useCallback, useEffect, useState } from 'react';
import { loadStripe } from '@stripe/stripe-js';
import {
  EmbeddedCheckout,
  EmbeddedCheckoutProvider,
} from '@stripe/react-stripe-js';
import { useCheckoutStore } from '@/stores/checkout';
import { useCartStore, useCartItems, useCartCoupon } from '@/stores/cart';
import { Button } from '@/components/ui/button';
import { Loader2, AlertCircle } from 'lucide-react';
import type { ShippingAddress } from '@csz/types';

const stripePromise = loadStripe(
  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!
);

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:4000';

interface PaymentStepProps {
  addresses: ShippingAddress[];
  userId: number;
}

export function PaymentStep({ addresses, userId }: PaymentStepProps) {
  const {
    shippingAddressId,
    useNewShippingAddress,
    newShippingAddress,
    useSameAsBilling,
    newBillingAddress,
    poReference,
    prevStep,
  } = useCheckoutStore();

  const items = useCartItems();
  const coupon = useCartCoupon();

  const [error, setError] = useState<string | null>(null);

  // Get shipping address details
  const shippingAddress = useNewShippingAddress
    ? newShippingAddress
    : addresses.find(a => a.documentId === shippingAddressId);

  // Get billing address details
  const billingAddress = useSameAsBilling ? undefined : newBillingAddress;

  const fetchClientSecret = useCallback(async () => {
    if (!shippingAddress) {
      throw new Error('Szallitasi cim szukseges');
    }

    const lineItems = items.map(item => ({
      productId: item.productDocumentId,
      variantId: item.variantDocumentId,
      quantity: item.quantity,
      name: item.name,
      variantName: item.variantName,
      sku: item.sku,
      price: item.price,
    }));

    const response = await fetch(`${API_URL}/checkout/create-session`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        lineItems,
        shippingAddress: {
          recipientName: shippingAddress.recipientName,
          street: shippingAddress.street,
          city: shippingAddress.city,
          postalCode: shippingAddress.postalCode,
          country: shippingAddress.country || 'Magyarorszag',
          phone: shippingAddress.phone,
        },
        billingAddress: billingAddress ? {
          recipientName: billingAddress.recipientName,
          street: billingAddress.street,
          city: billingAddress.city,
          postalCode: billingAddress.postalCode,
          country: billingAddress.country || 'Magyarorszag',
          companyName: billingAddress.companyName,
          vatNumber: billingAddress.vatNumber,
        } : undefined,
        couponCode: coupon?.code,
        poReference,
        userId,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || 'Hiba tortent');
    }

    const { clientSecret } = await response.json();
    return clientSecret;
  }, [items, shippingAddress, billingAddress, coupon, poReference, userId]);

  // Validate we have required data
  if (!shippingAddress) {
    return (
      <div className="p-6 border border-destructive rounded-lg">
        <div className="flex items-center gap-2 text-destructive mb-4">
          <AlertCircle className="h-5 w-5" />
          <span className="font-medium">Hiba</span>
        </div>
        <p className="text-muted-foreground mb-4">Szallitasi cim szukseges a fizeteshez.</p>
        <Button variant="outline" onClick={prevStep}>
          Vissza
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-semibold">Fizetes</h2>

      <div className="border rounded-lg p-4">
        <p className="text-sm text-muted-foreground mb-4">
          A fizetes biztonsagosan a Stripe rendszeren keresztul tortenik.
          Elfogadjuk a kartyas fizeteseket, Apple Pay-t es Google Pay-t.
        </p>

        <div id="checkout">
          <EmbeddedCheckoutProvider
            stripe={stripePromise}
            options={{ fetchClientSecret }}
          >
            <EmbeddedCheckout />
          </EmbeddedCheckoutProvider>
        </div>
      </div>

      {error && (
        <div className="p-4 border border-destructive rounded-lg">
          <p className="text-destructive text-sm">{error}</p>
        </div>
      )}

      <div className="flex justify-start pt-6 border-t">
        <Button variant="outline" onClick={prevStep}>
          Vissza az osszegzeshez
        </Button>
      </div>
    </div>
  );
}
```

Update `apps/web/src/app/[locale]/penztar/CheckoutClient.tsx`:

1. Add PaymentStep import
2. Pass userId to PaymentStep (need to get from session)

```typescript
// Add import at top
import { PaymentStep } from './steps/PaymentStep';

// Update props interface
interface CheckoutClientProps {
  initialAddresses: ShippingAddress[];
  userId: number;
}

// Update function signature
export function CheckoutClient({ initialAddresses, userId }: CheckoutClientProps) {

// In render, replace payment placeholder:
{step === 'payment' && (
  <PaymentStep addresses={initialAddresses} userId={userId} />
)}
```

Update `apps/web/src/app/[locale]/penztar/page.tsx` to pass userId:

```typescript
import { verifySession } from '@/lib/auth/dal';

export default async function CheckoutPage() {
  // Get session to extract userId
  const session = await requireAuth();

  // Fetch saved addresses
  const { data: addresses, error } = await getAddresses();

  // Get userId from session
  const sessionData = await verifySession();
  const userId = sessionData.session?.userId || 0;

  return (
    <main className="container mx-auto px-4 py-8 max-w-4xl">
      <h1 className="text-2xl font-bold mb-8">Penztar</h1>
      <CheckoutClient
        initialAddresses={addresses || []}
        userId={userId}
      />
    </main>
  );
}
```
  </action>
  <verify>
    - PaymentStep.tsx uses EmbeddedCheckout from @stripe/react-stripe-js
    - PaymentStep.tsx calls create-session endpoint
    - page.tsx passes userId to CheckoutClient
    - `pnpm --filter @csz/web build` compiles
  </verify>
  <done>Payment step created with Stripe Embedded Checkout</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds: `pnpm --filter @csz/web build` and `pnpm --filter @csz/api build`
2. Start all servers (API, CMS, Web)
3. Complete checkout flow to payment step
4. Stripe Embedded Checkout should render
5. Test payment with Stripe test card: 4242 4242 4242 4242

Stripe test cards:
- Success: 4242 4242 4242 4242
- Requires auth: 4000 0025 0000 3155
- Declined: 4000 0000 0000 9995

Use any future date for expiry and any 3 digits for CVC.
</verification>

<success_criteria>
- User can pay with credit/debit card via Stripe (PAY-01)
- Apple Pay option shows on supported devices (PAY-02)
- Google Pay option shows on supported browsers (PAY-03)
- Order created in Strapi before Stripe session
- Stripe session has order_id in metadata for webhook
- All prices verified server-side, not from client
</success_criteria>

<output>
After completion, create `.planning/phases/06-checkout-payments/06-06-SUMMARY.md`
</output>
