---
phase: 06-checkout-payments
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/package.json
  - apps/api/src/lib/stripe.ts
  - apps/api/src/index.ts
  - apps/api/src/routes/checkout/webhook.ts
autonomous: false
user_setup:
  - service: stripe
    why: "Payment processing"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard > Developers > API keys > Secret key"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard > Developers > Webhooks > Signing secret (after creating endpoint)"
    dashboard_config:
      - task: "Enable HUF currency"
        location: "Stripe Dashboard > Settings > Payment methods > Currencies"
      - task: "Enable card payments"
        location: "Stripe Dashboard > Settings > Payment methods > Cards"

must_haves:
  truths:
    - "Webhook endpoint receives Stripe events and verifies signatures"
    - "Order status updates to 'paid' when checkout.session.completed fires"
    - "Invalid webhook signatures return 400 error"
    - "Webhook handler is idempotent (same event twice doesn't double-update)"
  artifacts:
    - path: "apps/api/src/lib/stripe.ts"
      provides: "Stripe client singleton"
      contains: "new Stripe"
    - path: "apps/api/src/routes/checkout/webhook.ts"
      provides: "Webhook handler for Stripe events"
      contains: "checkout.session.completed"
  key_links:
    - from: "webhook.ts"
      to: "Strapi Order API"
      via: "fetch to update order status"
      pattern: "strapi.*orders"
---

<objective>
Set up Stripe SDK in Fastify API and create webhook handler for payment confirmation events.

Purpose: The webhook handler is critical for order fulfillment - it receives payment confirmation from Stripe and updates order status from "pending" to "paid". Without webhooks, order status would never update.

Output: Stripe client singleton, webhook endpoint at POST /webhook/stripe with signature verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-checkout-payments/06-RESEARCH.md

Reference existing API patterns:
@apps/api/src/index.ts
@apps/api/src/routes/cart/coupon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Stripe SDK and fastify-raw-body</name>
  <files>apps/api/package.json</files>
  <action>
Install Stripe server SDK and raw body plugin:

```bash
cd apps/api
pnpm add stripe fastify-raw-body
```

This adds:
- `stripe` - Official Stripe Node.js SDK (v17.x)
- `fastify-raw-body` - Required for webhook signature verification (need raw request body, not parsed JSON)

Add environment variable documentation to apps/api/.env.example if it doesn't exist:
```
# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
```
  </action>
  <verify>
    - stripe and fastify-raw-body in apps/api/package.json dependencies
    - `pnpm install` succeeds
  </verify>
  <done>Stripe SDK and raw body plugin installed</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe client singleton</name>
  <files>apps/api/src/lib/stripe.ts</files>
  <action>
Create Stripe client singleton at `apps/api/src/lib/stripe.ts`:

```typescript
import Stripe from 'stripe';

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('STRIPE_SECRET_KEY environment variable is required');
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2024-12-18.acacia', // Use latest API version
  typescript: true,
});

export type { Stripe };
```

This provides:
- Single Stripe client instance for entire API
- Type exports for use in route handlers
- Startup validation of required env var
  </action>
  <verify>
    - `apps/api/src/lib/stripe.ts` exports `stripe` and `Stripe` type
    - TypeScript compiles: `pnpm --filter @csz/api build`
  </verify>
  <done>Stripe client singleton created</done>
</task>

<task type="auto">
  <name>Task 3: Create Stripe webhook handler</name>
  <files>
    apps/api/src/routes/checkout/webhook.ts
    apps/api/src/index.ts
  </files>
  <action>
Create webhook handler at `apps/api/src/routes/checkout/webhook.ts`:

```typescript
import type { FastifyPluginAsync } from 'fastify';
import { stripe } from '../../lib/stripe.js';
import type Stripe from 'stripe';

const STRAPI_URL = process.env.STRAPI_URL || 'http://localhost:1337';
const STRAPI_API_TOKEN = process.env.STRAPI_API_TOKEN;

interface OrderUpdatePayload {
  data: {
    status: string;
    paymentId?: string;
    paidAt?: string;
  };
}

async function updateOrderStatus(
  orderId: string,
  status: string,
  paymentData?: { paymentId: string; paidAt: string }
): Promise<void> {
  const payload: OrderUpdatePayload = {
    data: {
      status,
      ...paymentData,
    },
  };

  const response = await fetch(`${STRAPI_URL}/api/orders/${orderId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${STRAPI_API_TOKEN}`,
    },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    throw new Error(`Failed to update order ${orderId}: ${response.statusText}`);
  }
}

export const webhookRoutes: FastifyPluginAsync = async (fastify) => {
  // POST /webhook/stripe - Stripe webhook handler
  fastify.post<{ Body: string }>('/webhook/stripe', {
    config: {
      rawBody: true,
    },
  }, async (request, reply) => {
    const sig = request.headers['stripe-signature'] as string;
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

    if (!webhookSecret) {
      fastify.log.error('STRIPE_WEBHOOK_SECRET not configured');
      return reply.status(500).send({ error: 'Webhook not configured' });
    }

    let event: Stripe.Event;

    try {
      // CRITICAL: Use rawBody for signature verification
      event = stripe.webhooks.constructEvent(
        request.rawBody as string,
        sig,
        webhookSecret
      );
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      fastify.log.error({ err }, 'Webhook signature verification failed');
      return reply.status(400).send({ error: `Webhook Error: ${message}` });
    }

    fastify.log.info({ type: event.type, id: event.id }, 'Received Stripe event');

    // Handle specific event types
    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session;
        const orderId = session.metadata?.order_id;

        if (!orderId) {
          fastify.log.warn({ sessionId: session.id }, 'No order_id in session metadata');
          break;
        }

        // Check payment status
        if (session.payment_status === 'paid') {
          await updateOrderStatus(orderId, 'paid', {
            paymentId: session.payment_intent as string,
            paidAt: new Date().toISOString(),
          });
          fastify.log.info({ orderId }, 'Order marked as paid');
        } else if (session.payment_status === 'unpaid') {
          // Bank transfer - waiting for payment
          fastify.log.info({ orderId }, 'Order awaiting bank transfer payment');
        }
        break;
      }

      case 'checkout.session.async_payment_succeeded': {
        // Bank transfer completed
        const session = event.data.object as Stripe.Checkout.Session;
        const orderId = session.metadata?.order_id;

        if (orderId) {
          await updateOrderStatus(orderId, 'paid', {
            paymentId: session.payment_intent as string,
            paidAt: new Date().toISOString(),
          });
          fastify.log.info({ orderId }, 'Bank transfer payment confirmed');
        }
        break;
      }

      case 'checkout.session.async_payment_failed': {
        // Bank transfer failed/expired
        const session = event.data.object as Stripe.Checkout.Session;
        const orderId = session.metadata?.order_id;

        if (orderId) {
          await updateOrderStatus(orderId, 'cancelled');
          fastify.log.info({ orderId }, 'Order cancelled due to failed payment');
        }
        break;
      }

      default:
        fastify.log.info({ type: event.type }, 'Unhandled event type');
    }

    // Always return 200 to acknowledge receipt
    return reply.status(200).send({ received: true });
  });
};
```

Update `apps/api/src/index.ts` to:
1. Register fastify-raw-body plugin
2. Register webhook routes

```typescript
// Add import at top
import rawBody from 'fastify-raw-body';
import { webhookRoutes } from './routes/checkout/webhook.js';

// Register raw body plugin (after Fastify instantiation, before routes)
await fastify.register(rawBody, {
  field: 'rawBody',
  global: false, // Only enable where needed
  encoding: 'utf8',
  runFirst: true,
});

// Register webhook routes (add after couponRoutes)
await fastify.register(webhookRoutes, { prefix: '/webhook' });
```

Note: The webhook endpoint will be at `POST /webhook/stripe`.
  </action>
  <verify>
    - `pnpm --filter @csz/api build` compiles without errors
    - webhook.ts exports webhookRoutes
    - index.ts imports rawBody and webhookRoutes
    - Webhook route registered at /webhook/stripe
  </verify>
  <done>Stripe webhook handler created with signature verification and order status updates</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build succeeds: `pnpm --filter @csz/api build`
2. API starts: `cd apps/api && pnpm dev`
3. Stripe client loads (check logs for any STRIPE_SECRET_KEY errors)

Test webhook endpoint (will fail signature but confirms route exists):
```bash
curl -X POST http://localhost:4000/webhook/stripe \
  -H "Content-Type: application/json" \
  -d '{"type":"test"}'
# Should return 400 (no signature) - this is correct!
```

For full webhook testing, use Stripe CLI:
```bash
stripe listen --forward-to localhost:4000/webhook/stripe
# Then trigger test events in another terminal
stripe trigger checkout.session.completed
```
</verification>

<success_criteria>
- Stripe SDK installed and configured
- Webhook endpoint at /webhook/stripe with signature verification
- checkout.session.completed updates order to "paid"
- checkout.session.async_payment_failed cancels order
- Invalid signatures return 400 error
</success_criteria>

<output>
After completion, create `.planning/phases/06-checkout-payments/06-02-SUMMARY.md`
</output>
