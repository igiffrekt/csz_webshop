---
phase: 02-product-catalog-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/cms/src/components/product/specification.json
  - apps/cms/src/components/product/certification.json
  - apps/cms/src/api/category/content-types/category/schema.json
autonomous: true

must_haves:
  truths:
    - "Specification component exists with key, value, unit fields"
    - "Certification component exists with name, standard, validUntil, certificate fields"
    - "Category content type exists with name, slug, description, image, parent/children hierarchy"
  artifacts:
    - path: "apps/cms/src/components/product/specification.json"
      provides: "Reusable key-value specification component"
      contains: "collectionName"
    - path: "apps/cms/src/components/product/certification.json"
      provides: "Certification entry component with PDF upload"
      contains: "collectionName"
    - path: "apps/cms/src/api/category/content-types/category/schema.json"
      provides: "Category collection type with hierarchy"
      contains: "collectionType"
  key_links:
    - from: "apps/cms/src/components/product/certification.json"
      to: "Strapi Media Library"
      via: "media field type"
      pattern: '"type":\\s*"media"'
    - from: "apps/cms/src/api/category/content-types/category/schema.json"
      to: "self"
      via: "parent/children self-referential relations"
      pattern: "api::category.category"
---

<objective>
Create foundational Strapi components and Category content type that Product will depend on.

Purpose: Establish reusable components for specifications and certifications, plus the Category content type. These must exist before the Product content type can reference them.

Output: Specification component, Certification component, Category collection type - all visible in Strapi Content-Type Builder.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-product-catalog-backend/02-RESEARCH.md

Reference schema patterns from research:
- Pattern 4: Specification Component
- Pattern 5: Certification Component
- Pattern 3: Category Collection Type
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Specification and Certification components</name>
  <files>
    apps/cms/src/components/product/specification.json
    apps/cms/src/components/product/certification.json
  </files>
  <action>
Create the components directory structure and JSON schema files:

1. Create `apps/cms/src/components/product/` directory

2. Create `specification.json` with fields:
   - key: string, required (e.g., "Weight", "Capacity", "Fire Rating")
   - value: string, required (e.g., "6kg", "21A 113B C")
   - unit: string, optional (e.g., "kg", "mm")

3. Create `certification.json` with fields:
   - name: string, required (e.g., "CE Mark", "EN3")
   - standard: string, optional (e.g., "EN 3-7:2004+A1:2007")
   - validUntil: date, optional (certification expiration)
   - certificate: media, single file (PDF certificate document)

Use the exact schema structure from 02-RESEARCH.md Patterns 4 and 5.
  </action>
  <verify>
Files exist:
- `ls apps/cms/src/components/product/specification.json`
- `ls apps/cms/src/components/product/certification.json`

JSON is valid:
- `node -e "require('./apps/cms/src/components/product/specification.json')"`
- `node -e "require('./apps/cms/src/components/product/certification.json')"`
  </verify>
  <done>Both component JSON files exist with valid schema structure</done>
</task>

<task type="auto">
  <name>Task 2: Create Category collection type</name>
  <files>
    apps/cms/src/api/category/content-types/category/schema.json
    apps/cms/src/api/category/controllers/category.ts
    apps/cms/src/api/category/services/category.ts
    apps/cms/src/api/category/routes/category.ts
  </files>
  <action>
Create the Category collection type with full directory structure:

1. Create directory structure:
   - `apps/cms/src/api/category/content-types/category/`
   - `apps/cms/src/api/category/controllers/`
   - `apps/cms/src/api/category/services/`
   - `apps/cms/src/api/category/routes/`

2. Create `schema.json` with fields (from 02-RESEARCH.md Pattern 3):
   - name: string, required
   - slug: uid field targeting name, required
   - description: text, optional
   - image: media, single image
   - parent: manyToOne relation to self (api::category.category), inversedBy children
   - children: oneToMany relation to self, mappedBy parent
   - products: manyToMany relation to api::product.product, mappedBy categories
   - Enable draftAndPublish: true

3. Create standard Strapi controller (apps/cms/src/api/category/controllers/category.ts):
   ```typescript
   import { factories } from '@strapi/strapi';
   export default factories.createCoreController('api::category.category');
   ```

4. Create standard Strapi service (apps/cms/src/api/category/services/category.ts):
   ```typescript
   import { factories } from '@strapi/strapi';
   export default factories.createCoreService('api::category.category');
   ```

5. Create standard Strapi routes (apps/cms/src/api/category/routes/category.ts):
   ```typescript
   import { factories } from '@strapi/strapi';
   export default factories.createCoreRouter('api::category.category');
   ```

NOTE: The products relation will show a warning in Strapi until Product content type is created in Plan 02-02. This is expected.
  </action>
  <verify>
Directory structure exists:
- `ls apps/cms/src/api/category/content-types/category/schema.json`
- `ls apps/cms/src/api/category/controllers/category.ts`

JSON is valid:
- `node -e "require('./apps/cms/src/api/category/content-types/category/schema.json')"`

Schema contains required fields:
- `grep -l "collectionType" apps/cms/src/api/category/content-types/category/schema.json`
- `grep -l "parent" apps/cms/src/api/category/content-types/category/schema.json`
  </verify>
  <done>Category collection type exists with hierarchical parent/children relations and products relation placeholder</done>
</task>

<task type="auto">
  <name>Task 3: Restart Strapi and verify components/category appear</name>
  <files>None (verification only)</files>
  <action>
1. Ensure Docker is running (PostgreSQL container)
2. Restart Strapi to load new schemas:
   - Stop any running Strapi process
   - Run `pnpm dev:cms` from project root
3. Wait for Strapi to fully start (watch for "Welcome back" or admin URL message)
4. Verify in logs that:
   - No schema errors appear
   - Components are registered
   - Category content type is registered (warning about missing Product relation is OK)
  </action>
  <verify>
Strapi starts without fatal errors:
- Look for "Welcome back" message or "Admin panel: http://localhost:1337/admin"
- No "Cannot find module" errors for components
- Category appears as registered API

Test API endpoint responds:
- `curl http://localhost:1337/api/categories` should return 200 (empty array or forbidden until permissions set)
  </verify>
  <done>Strapi starts successfully with components and Category content type registered. Category API endpoint is accessible (may return 403 until permissions configured in Plan 02-04)</done>
</task>

</tasks>

<verification>
Phase verification for Plan 02-01:

1. Component files exist and are valid JSON:
   - apps/cms/src/components/product/specification.json
   - apps/cms/src/components/product/certification.json

2. Category content type exists with:
   - schema.json with all required fields
   - controllers, services, routes TypeScript files
   - Self-referential parent/children relations

3. Strapi starts without fatal schema errors

4. Category shows in Strapi admin Content-Type Builder (visual check optional)
</verification>

<success_criteria>
- Specification component schema exists with key/value/unit fields
- Certification component schema exists with name/standard/validUntil/certificate fields
- Category collection type exists with hierarchical relations
- Strapi loads schemas without errors on restart
- Foundation ready for Product content type in Plan 02-02
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-catalog-backend/02-01-SUMMARY.md`
</output>
