---
phase: 05-authentication-user-accounts
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/lib/auth/session.ts
  - apps/web/src/lib/auth/dal.ts
  - apps/web/src/lib/auth/actions.ts
  - apps/web/package.json
  - apps/web/.env.example
autonomous: true
user_setup:
  - service: session
    why: "Session encryption requires a secret key"
    env_vars:
      - name: SESSION_SECRET
        source: "Generate with: openssl rand -base64 32"

must_haves:
  truths:
    - "Session can be encrypted and decrypted using jose"
    - "Session persists in httpOnly cookie"
    - "Login action calls Strapi and creates session"
    - "Logout action deletes session cookie"
    - "Register action calls Strapi and creates session"
  artifacts:
    - path: "apps/web/src/lib/auth/session.ts"
      provides: "JWT encryption/decryption, cookie management"
      exports: ["encrypt", "decrypt", "createSession", "deleteSession", "getSession"]
    - path: "apps/web/src/lib/auth/dal.ts"
      provides: "Data Access Layer for session verification"
      exports: ["verifySession", "requireAuth"]
    - path: "apps/web/src/lib/auth/actions.ts"
      provides: "Server Actions for auth operations"
      exports: ["loginAction", "registerAction", "logoutAction", "forgotPasswordAction", "resetPasswordAction"]
  key_links:
    - from: "apps/web/src/lib/auth/actions.ts"
      to: "Strapi /api/auth/local"
      via: "fetch POST"
      pattern: "fetch.*api/auth/local"
    - from: "apps/web/src/lib/auth/actions.ts"
      to: "apps/web/src/lib/auth/session.ts"
      via: "createSession import"
      pattern: "import.*createSession.*session"
    - from: "apps/web/src/lib/auth/dal.ts"
      to: "apps/web/src/lib/auth/session.ts"
      via: "getSession import"
      pattern: "import.*getSession.*session"
---

<objective>
Create Next.js session management and Server Actions for authentication

Purpose: Enable secure session handling with encrypted httpOnly cookies and provide login/register/logout functionality
Output: Session library with jose, DAL pattern for auth verification, Server Actions for all auth operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-authentication-user-accounts/05-RESEARCH.md

# Existing Next.js patterns
@apps/web/src/lib/api.ts
@apps/web/src/lib/cart-api.ts
@apps/web/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install jose and server-only packages</name>
  <files>
    - apps/web/package.json
    - apps/web/.env.example
  </files>
  <action>
Install required packages for session management.

1. Install packages in apps/web:
```bash
cd apps/web && pnpm add jose server-only
```

2. Update `apps/web/.env.example` to add SESSION_SECRET:
```
# Existing env vars...
NEXT_PUBLIC_API_URL=http://localhost:4000

# Session encryption secret (generate with: openssl rand -base64 32)
SESSION_SECRET=your-secret-key-here-at-least-32-chars
```

3. Add SESSION_SECRET to apps/web/.env (create if doesn't exist) with a development value. Generate a secure value for production.
  </action>
  <verify>
Check `apps/web/package.json` includes jose and server-only in dependencies.
  </verify>
  <done>
jose and server-only packages installed, SESSION_SECRET env var documented in .env.example.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session management library with jose</name>
  <files>
    - apps/web/src/lib/auth/session.ts
  </files>
  <action>
Create the session management library following Next.js official authentication patterns.

Create directory: `apps/web/src/lib/auth/`

Create `apps/web/src/lib/auth/session.ts`:
```typescript
import "server-only";
import { SignJWT, jwtVerify } from "jose";
import { cookies } from "next/headers";
import type { SessionPayload } from "@csz/types";

const secretKey = process.env.SESSION_SECRET;
if (!secretKey) {
  throw new Error("SESSION_SECRET environment variable is required");
}
const encodedKey = new TextEncoder().encode(secretKey);

const COOKIE_NAME = "csz-session";
const SESSION_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days

export async function encrypt(payload: SessionPayload): Promise<string> {
  return new SignJWT({ ...payload, expiresAt: payload.expiresAt.toISOString() })
    .setProtectedHeader({ alg: "HS256" })
    .setIssuedAt()
    .setExpirationTime("7d")
    .sign(encodedKey);
}

export async function decrypt(
  session: string | undefined
): Promise<SessionPayload | null> {
  if (!session) return null;
  try {
    const { payload } = await jwtVerify(session, encodedKey);
    return {
      ...payload,
      expiresAt: new Date(payload.expiresAt as string),
    } as SessionPayload;
  } catch {
    return null;
  }
}

export async function createSession(strapiResponse: {
  jwt: string;
  user: {
    id: number;
    documentId: string;
    email: string;
    username: string;
  };
}): Promise<void> {
  const expiresAt = new Date(Date.now() + SESSION_DURATION);

  const sessionPayload: SessionPayload = {
    jwt: strapiResponse.jwt,
    userId: strapiResponse.user.id,
    userDocumentId: strapiResponse.user.documentId,
    email: strapiResponse.user.email,
    username: strapiResponse.user.username,
    expiresAt,
  };

  const session = await encrypt(sessionPayload);

  const cookieStore = await cookies();
  cookieStore.set(COOKIE_NAME, session, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    expires: expiresAt,
    sameSite: "lax",
    path: "/",
  });
}

export async function deleteSession(): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.delete(COOKIE_NAME);
}

export async function getSession(): Promise<SessionPayload | null> {
  const cookieStore = await cookies();
  const session = cookieStore.get(COOKIE_NAME)?.value;
  return decrypt(session);
}

export async function updateSession(): Promise<void> {
  const session = await getSession();
  if (!session) return;

  // Extend session if it will expire in less than 1 day
  const oneDayFromNow = new Date(Date.now() + 24 * 60 * 60 * 1000);
  if (session.expiresAt < oneDayFromNow) {
    session.expiresAt = new Date(Date.now() + SESSION_DURATION);
    const encrypted = await encrypt(session);
    const cookieStore = await cookies();
    cookieStore.set(COOKIE_NAME, encrypted, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      expires: session.expiresAt,
      sameSite: "lax",
      path: "/",
    });
  }
}
```

Key points:
- Uses "server-only" to prevent client import
- Encrypts Strapi JWT inside our own signed JWT
- httpOnly cookie prevents XSS access
- sameSite: "lax" prevents CSRF
- secure: true in production requires HTTPS
- 7-day session duration
- updateSession() extends sessions about to expire
  </action>
  <verify>
File exists and exports encrypt, decrypt, createSession, deleteSession, getSession, updateSession functions.
  </verify>
  <done>
Session library created with jose JWT encryption, httpOnly cookie storage, and session management functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Data Access Layer (DAL) for session verification</name>
  <files>
    - apps/web/src/lib/auth/dal.ts
  </files>
  <action>
Create the DAL pattern for session verification in Server Components and Server Actions.

Create `apps/web/src/lib/auth/dal.ts`:
```typescript
import "server-only";
import { cache } from "react";
import { redirect } from "next/navigation";
import { getSession, type SessionPayload } from "./session";

export type { SessionPayload };

interface AuthResult {
  isAuth: true;
  session: SessionPayload;
}

interface UnauthResult {
  isAuth: false;
  session: null;
}

/**
 * Verify session without redirecting. Use for conditional rendering.
 * Result is cached per request via React cache().
 */
export const verifySession = cache(
  async (): Promise<AuthResult | UnauthResult> => {
    const session = await getSession();

    if (!session || session.expiresAt < new Date()) {
      return { isAuth: false, session: null };
    }

    return { isAuth: true, session };
  }
);

/**
 * Require authentication, redirect to login if not authenticated.
 * Use in pages/layouts that require login.
 */
export const requireAuth = cache(async (): Promise<SessionPayload> => {
  const { isAuth, session } = await verifySession();

  if (!isAuth) {
    redirect("/hu/auth/bejelentkezes");
  }

  return session;
});

/**
 * Get current user ID if authenticated, null otherwise.
 * Useful for optional personalization.
 */
export async function getCurrentUserId(): Promise<number | null> {
  const { isAuth, session } = await verifySession();
  return isAuth ? session.userId : null;
}

/**
 * Get Strapi JWT for authenticated API calls.
 * Returns null if not authenticated.
 */
export async function getStrapiJwt(): Promise<string | null> {
  const { isAuth, session } = await verifySession();
  return isAuth ? session.jwt : null;
}
```

Key points:
- Uses "server-only" to prevent client import
- cache() deduplicates session checks within a request
- verifySession for conditional rendering
- requireAuth for protected pages (redirects to login)
- getCurrentUserId for optional personalization
- getStrapiJwt for authenticated Strapi API calls
  </action>
  <verify>
File exists and exports verifySession, requireAuth, getCurrentUserId, getStrapiJwt functions.
  </verify>
  <done>
DAL created with cached session verification, requireAuth redirect, and helper functions for getting user ID and Strapi JWT.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Server Actions for authentication operations</name>
  <files>
    - apps/web/src/lib/auth/actions.ts
  </files>
  <action>
Create Server Actions for login, register, logout, forgot password, and reset password.

Create `apps/web/src/lib/auth/actions.ts`:
```typescript
"use server";

import { redirect } from "next/navigation";
import { z } from "zod";
import { createSession, deleteSession } from "./session";

const STRAPI_URL = process.env.STRAPI_URL || "http://localhost:1337";

// Validation schemas
const loginSchema = z.object({
  identifier: z.string().email("Ervenytelen email cim"),
  password: z.string().min(6, "A jelszo legalabb 6 karakter"),
});

const registerSchema = z
  .object({
    username: z.string().min(3, "A felhasznalonev legalabb 3 karakter"),
    email: z.string().email("Ervenytelen email cim"),
    password: z.string().min(6, "A jelszo legalabb 6 karakter"),
    passwordConfirm: z.string(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    phone: z.string().optional(),
    companyName: z.string().optional(),
    vatNumber: z.string().optional(),
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: "A jelszavak nem egyeznek",
    path: ["passwordConfirm"],
  });

const forgotPasswordSchema = z.object({
  email: z.string().email("Ervenytelen email cim"),
});

const resetPasswordSchema = z
  .object({
    code: z.string().min(1, "Hianyzik a visszaallitasi kod"),
    password: z.string().min(6, "A jelszo legalabb 6 karakter"),
    passwordConfirmation: z.string(),
  })
  .refine((data) => data.password === data.passwordConfirmation, {
    message: "A jelszavak nem egyeznek",
    path: ["passwordConfirmation"],
  });

// Auth state returned from actions
export interface AuthState {
  error?: string;
  fieldErrors?: Record<string, string[]>;
  success?: boolean;
}

/**
 * Login with email and password
 */
export async function loginAction(
  prevState: AuthState,
  formData: FormData
): Promise<AuthState> {
  const validatedFields = loginSchema.safeParse({
    identifier: formData.get("email"),
    password: formData.get("password"),
  });

  if (!validatedFields.success) {
    return {
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  try {
    const res = await fetch(`${STRAPI_URL}/api/auth/local`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(validatedFields.data),
    });

    if (!res.ok) {
      const error = await res.json();
      return {
        error: error.error?.message || "Hibas email cim vagy jelszo",
      };
    }

    const data = await res.json();
    await createSession(data);
  } catch {
    return {
      error: "Hiba tortent a bejelentkezes soran. Probald ujra kesobb.",
    };
  }

  // Get redirect URL from form or default to account page
  const redirectTo = formData.get("redirectTo") as string;
  redirect(redirectTo || "/hu/fiok");
}

/**
 * Register new account
 */
export async function registerAction(
  prevState: AuthState,
  formData: FormData
): Promise<AuthState> {
  const validatedFields = registerSchema.safeParse({
    username: formData.get("username"),
    email: formData.get("email"),
    password: formData.get("password"),
    passwordConfirm: formData.get("passwordConfirm"),
    firstName: formData.get("firstName") || undefined,
    lastName: formData.get("lastName") || undefined,
    phone: formData.get("phone") || undefined,
    companyName: formData.get("companyName") || undefined,
    vatNumber: formData.get("vatNumber") || undefined,
  });

  if (!validatedFields.success) {
    return {
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  // Remove passwordConfirm before sending to Strapi
  const { passwordConfirm, ...registerData } = validatedFields.data;

  try {
    const res = await fetch(`${STRAPI_URL}/api/auth/local/register`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(registerData),
    });

    if (!res.ok) {
      const error = await res.json();
      // Handle common Strapi registration errors
      const message = error.error?.message || "";
      if (message.includes("Email") && message.includes("taken")) {
        return { error: "Ez az email cim mar regisztralva van" };
      }
      if (message.includes("Username") && message.includes("taken")) {
        return { error: "Ez a felhasznalonev mar foglalt" };
      }
      return {
        error: error.error?.message || "Regisztracio sikertelen",
      };
    }

    const data = await res.json();
    await createSession(data);
  } catch {
    return {
      error: "Hiba tortent a regisztracio soran. Probald ujra kesobb.",
    };
  }

  redirect("/hu/fiok");
}

/**
 * Logout - delete session and redirect to home
 */
export async function logoutAction(): Promise<void> {
  await deleteSession();
  redirect("/hu");
}

/**
 * Request password reset email
 */
export async function forgotPasswordAction(
  prevState: AuthState,
  formData: FormData
): Promise<AuthState> {
  const validatedFields = forgotPasswordSchema.safeParse({
    email: formData.get("email"),
  });

  if (!validatedFields.success) {
    return {
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  try {
    const res = await fetch(`${STRAPI_URL}/api/auth/forgot-password`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(validatedFields.data),
    });

    // Always show success to prevent email enumeration
    // Even if email doesn't exist, don't reveal that
    if (!res.ok) {
      const error = await res.json();
      // Log error but don't expose to user
      console.error("Forgot password error:", error);
    }
  } catch (error) {
    console.error("Forgot password error:", error);
  }

  // Always return success to prevent email enumeration
  return {
    success: true,
  };
}

/**
 * Reset password with code from email
 */
export async function resetPasswordAction(
  prevState: AuthState,
  formData: FormData
): Promise<AuthState> {
  const validatedFields = resetPasswordSchema.safeParse({
    code: formData.get("code"),
    password: formData.get("password"),
    passwordConfirmation: formData.get("passwordConfirmation"),
  });

  if (!validatedFields.success) {
    return {
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  try {
    const res = await fetch(`${STRAPI_URL}/api/auth/reset-password`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(validatedFields.data),
    });

    if (!res.ok) {
      const error = await res.json();
      const message = error.error?.message || "";
      if (message.includes("code") || message.includes("invalid")) {
        return { error: "Ervenytelen vagy lejart visszaallitasi link" };
      }
      return {
        error: error.error?.message || "Jelszo visszaallitas sikertelen",
      };
    }
  } catch {
    return {
      error: "Hiba tortent. Probald ujra kesobb.",
    };
  }

  redirect("/hu/auth/bejelentkezes?reset=success");
}
```

Key points:
- Uses zod for validation (already in project)
- All validation errors in Hungarian
- forgotPasswordAction always returns success to prevent email enumeration
- registerAction handles custom fields from extended user model
- loginAction supports redirectTo for post-login redirect
- All actions redirect on success via server-side redirect()
  </action>
  <verify>
File exists and exports loginAction, registerAction, logoutAction, forgotPasswordAction, resetPasswordAction, and AuthState type.
  </verify>
  <done>
Server Actions created for login, register, logout, forgot password, and reset password with zod validation and Hungarian error messages.
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm build` in apps/web - should compile without errors
2. Check imports work: `import { createSession } from "@/lib/auth/session"` resolves
3. Check DAL imports: `import { requireAuth } from "@/lib/auth/dal"` resolves
4. Check actions exports: all 5 actions are exported from actions.ts
5. Verify zod is available (already in project from existing forms)
</verification>

<success_criteria>
1. jose and server-only packages installed in apps/web
2. SESSION_SECRET documented in .env.example
3. session.ts provides encrypt, decrypt, createSession, deleteSession, getSession
4. dal.ts provides verifySession, requireAuth with React cache()
5. actions.ts provides loginAction, registerAction, logoutAction, forgotPasswordAction, resetPasswordAction
6. All error messages are in Hungarian
</success_criteria>

<output>
After completion, create `.planning/phases/05-authentication-user-accounts/05-02-SUMMARY.md`
</output>
