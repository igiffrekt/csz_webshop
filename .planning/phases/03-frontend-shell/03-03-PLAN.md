---
phase: 03-frontend-shell
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - apps/web/src/app/[locale]/termekek/page.tsx
  - apps/web/src/components/product/ProductGrid.tsx
  - apps/web/src/components/product/ProductFilters.tsx
  - apps/web/src/components/product/SearchInput.tsx
  - apps/web/src/components/product/Pagination.tsx
  - apps/web/src/lib/api.ts
  - apps/web/src/messages/hu.json
  - apps/web/src/components/ui/input.tsx
  - apps/web/src/components/ui/select.tsx
  - apps/web/src/components/ui/checkbox.tsx
autonomous: true

must_haves:
  truths:
    - "User can view a grid of all products"
    - "User can search products by name"
    - "User can filter products by category"
    - "User can filter products by fire class (A, B, C)"
    - "User can filter products by certification (CE, EN3)"
    - "User can paginate through product results"
    - "URL reflects current filter/search state"
  artifacts:
    - path: "apps/web/src/app/[locale]/termekek/page.tsx"
      provides: "Product listing page with server-side data fetching"
      min_lines: 50
    - path: "apps/web/src/components/product/ProductFilters.tsx"
      provides: "Filter UI with nuqs URL state including fire class and certification filters"
      contains: "useQueryState"
    - path: "apps/web/src/components/product/SearchInput.tsx"
      provides: "Search input with debouncing"
      contains: "useQueryState"
    - path: "apps/web/src/components/product/Pagination.tsx"
      provides: "Page navigation controls"
      min_lines: 30
  key_links:
    - from: "apps/web/src/app/[locale]/termekek/page.tsx"
      to: "searchParams"
      via: "Server Component reads URL params"
      pattern: "searchParams.*category|search|page|fireClass|certification"
    - from: "apps/web/src/components/product/ProductFilters.tsx"
      to: "nuqs"
      via: "useQueryState updates URL"
      pattern: "useQueryState"
---

<objective>
Build the product listing page with search, filtering, and pagination using nuqs for URL state management. Users can browse all products, search by name, filter by category, filter by fire class (A/B/C), filter by certification (CE, EN3), and navigate through pages.

Purpose: Enable users to discover products in the catalog, addressing PROD-01 (browse by category), PROD-02 (search), and PROD-03 (filter by fire class and certification).

Output: Fully functional /termekek product listing page with responsive grid and working filters including fire class and certification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-shell/03-RESEARCH.md
@.planning/phases/03-frontend-shell/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProductFilters and SearchInput with nuqs</name>
  <files>
    apps/web/src/components/product/ProductFilters.tsx
    apps/web/src/components/product/SearchInput.tsx
    apps/web/src/app/[locale]/layout.tsx
    apps/web/src/components/ui/input.tsx
    apps/web/src/components/ui/select.tsx
    apps/web/src/components/ui/checkbox.tsx
    apps/web/src/messages/hu.json
  </files>
  <action>
Install nuqs for URL state management and add shadcn/ui components needed.

```bash
cd apps/web && pnpm dlx shadcn@latest add input select checkbox
```

**Configure nuqs in layout.tsx:**
Add NuqsAdapter provider from nuqs/adapters/next/app:
```typescript
import { NuqsAdapter } from 'nuqs/adapters/next/app';

// In the layout return, wrap children:
<NuqsAdapter>{children}</NuqsAdapter>
```

**Create SearchInput.tsx (Client Component):**
```typescript
'use client';

import { useQueryState, parseAsString } from 'nuqs';
import { Input } from '@/components/ui/input';
import { Search } from 'lucide-react';
import { useTranslations } from 'next-intl';

export function SearchInput() {
  const t = useTranslations('products');
  const [search, setSearch] = useQueryState('q', parseAsString.withOptions({
    throttleMs: 500,
    shallow: false, // Trigger server re-render
  }));

  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        type="search"
        placeholder={t('search')}
        value={search ?? ''}
        onChange={(e) => setSearch(e.target.value || null)}
        className="pl-10"
      />
    </div>
  );
}
```

**Create ProductFilters.tsx (Client Component):**
```typescript
'use client';

import { useQueryState, parseAsString, parseAsArrayOf } from 'nuqs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { useTranslations } from 'next-intl';
import type { Category } from '@csz/types';

interface ProductFiltersProps {
  categories: Category[];
}

// Fire class options for fire safety equipment
const FIRE_CLASSES = ['A', 'B', 'C'] as const;

// Common certifications for fire safety equipment
const CERTIFICATIONS = ['CE', 'EN3'] as const;

export function ProductFilters({ categories }: ProductFiltersProps) {
  const t = useTranslations('products');

  // Category filter
  const [category, setCategory] = useQueryState('category', parseAsString.withOptions({
    shallow: false,
  }));

  // Fire class filter (single select dropdown)
  const [fireClass, setFireClass] = useQueryState('fireClass', parseAsString.withOptions({
    shallow: false,
  }));

  // Certification filter (multi-select checkboxes)
  const [certifications, setCertifications] = useQueryState('cert', parseAsArrayOf(parseAsString, ',').withOptions({
    shallow: false,
  }));

  const handleCertificationChange = (cert: string, checked: boolean) => {
    const current = certifications ?? [];
    if (checked) {
      setCertifications([...current, cert]);
    } else {
      const updated = current.filter(c => c !== cert);
      setCertifications(updated.length > 0 ? updated : null);
    }
  };

  return (
    <div className="flex flex-wrap gap-4 items-start">
      {/* Category dropdown */}
      <Select value={category ?? 'all'} onValueChange={(v) => setCategory(v === 'all' ? null : v)}>
        <SelectTrigger className="w-[200px]">
          <SelectValue placeholder={t('allCategories')} />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">{t('allCategories')}</SelectItem>
          {categories.map((cat) => (
            <SelectItem key={cat.documentId} value={cat.slug}>
              {cat.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Fire class dropdown */}
      <Select value={fireClass ?? 'all'} onValueChange={(v) => setFireClass(v === 'all' ? null : v)}>
        <SelectTrigger className="w-[180px]">
          <SelectValue placeholder={t('allFireClasses')} />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">{t('allFireClasses')}</SelectItem>
          {FIRE_CLASSES.map((fc) => (
            <SelectItem key={fc} value={fc}>
              {t('fireClass')} {fc}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {/* Certification checkboxes */}
      <div className="flex flex-col gap-2">
        <span className="text-sm font-medium">{t('certifications')}</span>
        <div className="flex gap-4">
          {CERTIFICATIONS.map((cert) => (
            <div key={cert} className="flex items-center space-x-2">
              <Checkbox
                id={`cert-${cert}`}
                checked={(certifications ?? []).includes(cert)}
                onCheckedChange={(checked) => handleCertificationChange(cert, checked === true)}
              />
              <Label htmlFor={`cert-${cert}`} className="text-sm cursor-pointer">
                {cert}
              </Label>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

**Update hu.json:**
```json
{
  "products": {
    "title": "Termékek",
    "search": "Keresés termékek között...",
    "filter": "Szűrés",
    "allCategories": "Minden kategória",
    "allFireClasses": "Minden tűzosztály",
    "fireClass": "Tűzosztály",
    "certifications": "Tanúsítványok",
    "noResults": "Nincs találat a keresési feltételeknek megfelelően",
    "showing": "{count} termék megjelenítve",
    "clearFilters": "Szűrők törlése"
  }
}
```
  </action>
  <verify>
1. Import SearchInput and ProductFilters in a test page
2. Type in search - URL updates with ?q=... after 500ms debounce
3. Select category - URL updates with ?category=...
4. Select fire class - URL updates with ?fireClass=A (or B/C)
5. Check CE checkbox - URL updates with ?cert=CE
6. Check both CE and EN3 - URL shows ?cert=CE,EN3
7. Refresh page - filter values persist from URL
8. Clear search - q parameter removed from URL
  </verify>
  <done>SearchInput and ProductFilters update URL state via nuqs including fire class and certification filters, values persist on refresh</done>
</task>

<task type="auto">
  <name>Task 2: Create ProductGrid and Pagination components</name>
  <files>
    apps/web/src/components/product/ProductGrid.tsx
    apps/web/src/components/product/Pagination.tsx
    apps/web/src/messages/hu.json
  </files>
  <action>
**Create ProductGrid.tsx (Server Component):**
```typescript
import { ProductCard } from './ProductCard';
import type { Product } from '@csz/types';

interface ProductGridProps {
  products: Product[];
}

export function ProductGrid({ products }: ProductGridProps) {
  if (products.length === 0) {
    return null; // Parent handles empty state
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {products.map((product) => (
        <ProductCard key={product.documentId} product={product} />
      ))}
    </div>
  );
}
```

**Create Pagination.tsx (Client Component):**
```typescript
'use client';

import { useQueryState, parseAsInteger } from 'nuqs';
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { useTranslations } from 'next-intl';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
}

export function Pagination({ currentPage, totalPages, totalItems }: PaginationProps) {
  const t = useTranslations('pagination');
  const [page, setPage] = useQueryState('page', parseAsInteger.withDefault(1).withOptions({
    shallow: false,
  }));

  if (totalPages <= 1) {
    return null;
  }

  const handlePrevious = () => {
    if (currentPage > 1) {
      setPage(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      setPage(currentPage + 1);
    }
  };

  return (
    <nav className="flex items-center justify-between py-8">
      <p className="text-sm text-muted-foreground">
        {t('showing', { page: currentPage, total: totalPages })}
      </p>
      <div className="flex gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={handlePrevious}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4 mr-1" />
          {t('previous')}
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={handleNext}
          disabled={currentPage >= totalPages}
        >
          {t('next')}
          <ChevronRight className="h-4 w-4 ml-1" />
        </Button>
      </div>
    </nav>
  );
}
```

**Update hu.json:**
```json
{
  "pagination": {
    "previous": "Előző",
    "next": "Következő",
    "showing": "{page}. oldal / {total}"
  }
}
```

Add lucide-react icons if not already installed:
```bash
cd apps/web && pnpm add lucide-react
```
  </action>
  <verify>
1. ProductGrid renders products in responsive grid layout
2. 4 columns on xl, 3 on lg, 2 on sm, 1 on mobile
3. Pagination shows "1. oldal / 3" format
4. Previous button disabled on page 1
5. Clicking Next updates URL to ?page=2
  </verify>
  <done>ProductGrid displays responsive grid, Pagination controls page via URL state</done>
</task>

<task type="auto">
  <name>Task 3: Build product listing page with all components</name>
  <files>
    apps/web/src/app/[locale]/termekek/page.tsx
    apps/web/src/lib/api.ts
    apps/web/src/components/product/EmptyState.tsx
  </files>
  <action>
**Create EmptyState.tsx (Server Component):**
```typescript
import { useTranslations } from 'next-intl';
import { Package } from 'lucide-react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';

interface EmptyStateProps {
  hasFilters?: boolean;
}

export function EmptyState({ hasFilters }: EmptyStateProps) {
  const t = useTranslations('products');

  return (
    <div className="flex flex-col items-center justify-center py-16 text-center">
      <Package className="h-12 w-12 text-muted-foreground mb-4" />
      <h3 className="text-lg font-medium mb-2">{t('noResults')}</h3>
      {hasFilters && (
        <Link href="/termekek">
          <Button variant="outline" className="mt-4">
            {t('clearFilters')}
          </Button>
        </Link>
      )}
    </div>
  );
}
```

**Update ProductFilters interface in api.ts to include fireClass and certification:**
```typescript
export interface ProductFilters {
  category?: string;
  search?: string;
  featured?: boolean;
  onSale?: boolean;
  fireClass?: string;           // Fire class filter: 'A', 'B', or 'C'
  certification?: string[];     // Certification filter: ['CE', 'EN3']
  page?: number;
  pageSize?: number;
}
```

**Update getProducts in api.ts to handle fireClass and certification filters:**
```typescript
export async function getProducts(filters: ProductFilters = {}): Promise<StrapiListResponse<Product>> {
  const query = qs.stringify({
    filters: {
      ...(filters.category && { categories: { slug: { $eq: filters.category } } }),
      ...(filters.search && { name: { $containsi: filters.search } }),
      ...(filters.featured && { isFeatured: { $eq: true } }),
      ...(filters.onSale && { isOnSale: { $eq: true } }),
      // Fire class filter - filters products by fire class in specifications
      // Assumes products have a specification with name "Tűzosztály" or "Fire Class"
      ...(filters.fireClass && {
        specifications: {
          $or: [
            { name: 'Tűzosztály', value: { $containsi: filters.fireClass } },
            { name: 'Fire Class', value: { $containsi: filters.fireClass } },
          ]
        }
      }),
      // Certification filter - filters products by certification name
      ...(filters.certification && filters.certification.length > 0 && {
        certifications: {
          name: { $in: filters.certification }
        }
      }),
    },
    populate: {
      images: { fields: ['url', 'alternativeText', 'width', 'height', 'formats'] },
      categories: { fields: ['name', 'slug'] },
      certifications: true,
      specifications: true,
    },
    pagination: {
      page: filters.page || 1,
      pageSize: filters.pageSize || 12,
    },
    sort: ['createdAt:desc'],
  }, { encodeValuesOnly: true });

  const res = await fetch(`${STRAPI_URL}/api/products?${query}`, {
    next: { revalidate: 60 }, // ISR: revalidate every 60 seconds
  });

  if (!res.ok) {
    throw new Error(`Failed to fetch products: ${res.status}`);
  }

  return res.json();
}
```

**Create /termekek/page.tsx:**
```typescript
import { Metadata } from 'next';
import { getProducts, getCategories } from '@/lib/api';
import { ProductGrid } from '@/components/product/ProductGrid';
import { ProductFilters } from '@/components/product/ProductFilters';
import { SearchInput } from '@/components/product/SearchInput';
import { Pagination } from '@/components/product/Pagination';
import { EmptyState } from '@/components/product/EmptyState';
import { getTranslations } from 'next-intl/server';

export async function generateMetadata(): Promise<Metadata> {
  const t = await getTranslations('products');
  return {
    title: t('title'),
    description: 'Böngésszen tűzvédelmi eszközök széles választékában',
  };
}

interface Props {
  searchParams: Promise<{
    category?: string;
    q?: string;
    page?: string;
    fireClass?: string;
    cert?: string;
  }>;
}

export default async function ProductsPage({ searchParams }: Props) {
  const params = await searchParams;
  const t = await getTranslations('products');

  // Fetch categories for filter dropdown
  const categoriesResponse = await getCategories();

  // Parse certification parameter (comma-separated string to array)
  const certifications = params.cert ? params.cert.split(',') : undefined;

  // Fetch products with all filters including fire class and certification
  const productsResponse = await getProducts({
    category: params.category,
    search: params.q,
    fireClass: params.fireClass,
    certification: certifications,
    page: params.page ? parseInt(params.page, 10) : 1,
    pageSize: 12,
  });

  const { data: products, meta } = productsResponse;
  const { pagination } = meta;
  const hasFilters = !!(params.category || params.q || params.fireClass || params.cert);

  return (
    <main className="container mx-auto px-4 py-8">
      {/* Page header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">{t('title')}</h1>
        {pagination && (
          <p className="text-muted-foreground">
            {t('showing', { count: pagination.total })}
          </p>
        )}
      </div>

      {/* Filters row */}
      <div className="flex flex-col gap-4 mb-8">
        <div className="flex-1 max-w-md">
          <SearchInput />
        </div>
        <ProductFilters categories={categoriesResponse.data} />
      </div>

      {/* Product grid or empty state */}
      {products.length > 0 ? (
        <>
          <ProductGrid products={products} />
          {pagination && (
            <Pagination
              currentPage={pagination.page}
              totalPages={pagination.pageCount}
              totalItems={pagination.total}
            />
          )}
        </>
      ) : (
        <EmptyState hasFilters={hasFilters} />
      )}
    </main>
  );
}
```

**Handle all filter cases in api.ts getProducts:**
- category slug filter
- search (name containsi)
- fireClass filter (via specifications component)
- certification filter (via certifications relation)
- page and pageSize
- Return empty array gracefully if API fails
  </action>
  <verify>
1. Start Strapi and add 2-3 products with:
   - Different categories
   - Specifications including "Tűzosztály" with values A, B, or C
   - Certifications named "CE" and/or "EN3"
2. Navigate to /termekek
3. Product grid shows all products
4. Type in search box - grid filters after 500ms, URL shows ?q=...
5. Select category from dropdown - grid filters, URL shows ?category=...
6. Select fire class A - grid filters to show only fire class A products, URL shows ?fireClass=A
7. Check CE checkbox - grid filters to show only CE certified products, URL shows ?cert=CE
8. Check both CE and EN3 - URL shows ?cert=CE,EN3, grid shows products with either certification
9. Combine search + category + fireClass + cert - all filters applied together
10. Navigate to page 2 (if enough products) - URL shows ?page=2
11. Refresh page - filters persist from URL
12. "Szűrők törlése" button appears when filters active
  </verify>
  <done>Product listing page shows products, search/filter/pagination including fire class and certification filters all work via URL state</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Navigate to /termekek
2. Page title "Termékek" displays
3. Search input accepts text and filters products after debounce
4. Category dropdown lists categories from Strapi
5. Selecting category filters product grid
6. Fire class dropdown filters by fire class (A, B, C)
7. Certification checkboxes filter by CE and EN3
8. Pagination shows and navigates between pages
9. URL reflects all filter state (?q=...&category=...&fireClass=...&cert=...&page=...)
10. Browser back/forward navigates filter history
11. Direct URL access with params shows correct filtered results
12. Empty state shows when no products match filters
</verification>

<success_criteria>
- Product listing page at /termekek renders product grid
- Search filters products by name (PROD-02)
- Category dropdown filters by category (PROD-01)
- Fire class dropdown filters by fire class A/B/C (PROD-03)
- Certification checkboxes filter by CE and EN3 (PROD-03)
- Pagination works for large product sets
- All filter state managed via URL (nuqs)
- Page is responsive on all viewport sizes
- All UI text in Hungarian
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-shell/03-03-SUMMARY.md`
</output>
