---
phase: 03-frontend-shell
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - apps/web/src/app/[locale]/termekek/page.tsx
  - apps/web/src/components/product/ProductGrid.tsx
  - apps/web/src/components/product/ProductFilters.tsx
  - apps/web/src/components/product/SearchInput.tsx
  - apps/web/src/components/product/Pagination.tsx
  - apps/web/src/lib/api.ts
  - apps/web/src/messages/hu.json
  - apps/web/src/components/ui/input.tsx
  - apps/web/src/components/ui/select.tsx
autonomous: true

must_haves:
  truths:
    - "User can view a grid of all products"
    - "User can search products by name"
    - "User can filter products by category"
    - "User can paginate through product results"
    - "URL reflects current filter/search state"
  artifacts:
    - path: "apps/web/src/app/[locale]/termekek/page.tsx"
      provides: "Product listing page with server-side data fetching"
      min_lines: 50
    - path: "apps/web/src/components/product/ProductFilters.tsx"
      provides: "Filter UI with nuqs URL state"
      contains: "useQueryState"
    - path: "apps/web/src/components/product/SearchInput.tsx"
      provides: "Search input with debouncing"
      contains: "useQueryState"
    - path: "apps/web/src/components/product/Pagination.tsx"
      provides: "Page navigation controls"
      min_lines: 30
  key_links:
    - from: "apps/web/src/app/[locale]/termekek/page.tsx"
      to: "searchParams"
      via: "Server Component reads URL params"
      pattern: "searchParams.*category|search|page"
    - from: "apps/web/src/components/product/ProductFilters.tsx"
      to: "nuqs"
      via: "useQueryState updates URL"
      pattern: "useQueryState"
---

<objective>
Build the product listing page with search, filtering, and pagination using nuqs for URL state management. Users can browse all products, search by name, filter by category, and navigate through pages.

Purpose: Enable users to discover products in the catalog, addressing PROD-01 (browse by category), PROD-02 (search), and PROD-03 (filter).

Output: Fully functional /termekek product listing page with responsive grid and working filters.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-shell/03-RESEARCH.md
@.planning/phases/03-frontend-shell/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProductFilters and SearchInput with nuqs</name>
  <files>
    apps/web/src/components/product/ProductFilters.tsx
    apps/web/src/components/product/SearchInput.tsx
    apps/web/src/app/[locale]/layout.tsx
    apps/web/src/components/ui/input.tsx
    apps/web/src/components/ui/select.tsx
    apps/web/src/messages/hu.json
  </files>
  <action>
Install nuqs for URL state management and add shadcn/ui components needed.

```bash
cd apps/web && pnpm dlx shadcn@latest add input select
```

**Configure nuqs in layout.tsx:**
Add NuqsAdapter provider from nuqs/adapters/next/app:
```typescript
import { NuqsAdapter } from 'nuqs/adapters/next/app';

// In the layout return, wrap children:
<NuqsAdapter>{children}</NuqsAdapter>
```

**Create SearchInput.tsx (Client Component):**
```typescript
'use client';

import { useQueryState, parseAsString } from 'nuqs';
import { Input } from '@/components/ui/input';
import { Search } from 'lucide-react';
import { useTranslations } from 'next-intl';

export function SearchInput() {
  const t = useTranslations('products');
  const [search, setSearch] = useQueryState('q', parseAsString.withOptions({
    throttleMs: 500,
    shallow: false, // Trigger server re-render
  }));

  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        type="search"
        placeholder={t('search')}
        value={search ?? ''}
        onChange={(e) => setSearch(e.target.value || null)}
        className="pl-10"
      />
    </div>
  );
}
```

**Create ProductFilters.tsx (Client Component):**
```typescript
'use client';

import { useQueryState, parseAsString } from 'nuqs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useTranslations } from 'next-intl';
import type { Category } from '@csz/types';

interface ProductFiltersProps {
  categories: Category[];
}

export function ProductFilters({ categories }: ProductFiltersProps) {
  const t = useTranslations('products');
  const [category, setCategory] = useQueryState('category', parseAsString.withOptions({
    shallow: false,
  }));

  return (
    <div className="flex flex-wrap gap-4 items-center">
      <Select value={category ?? 'all'} onValueChange={(v) => setCategory(v === 'all' ? null : v)}>
        <SelectTrigger className="w-[200px]">
          <SelectValue placeholder={t('allCategories')} />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">{t('allCategories')}</SelectItem>
          {categories.map((cat) => (
            <SelectItem key={cat.documentId} value={cat.slug}>
              {cat.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}
```

**Update hu.json:**
```json
{
  "products": {
    "title": "Termékek",
    "search": "Keresés termékek között...",
    "filter": "Szűrés",
    "allCategories": "Minden kategória",
    "noResults": "Nincs találat a keresési feltételeknek megfelelően",
    "showing": "{count} termék megjelenítve",
    "clearFilters": "Szűrők törlése"
  }
}
```
  </action>
  <verify>
1. Import SearchInput and ProductFilters in a test page
2. Type in search - URL updates with ?q=... after 500ms debounce
3. Select category - URL updates with ?category=...
4. Refresh page - filter values persist from URL
5. Clear search - q parameter removed from URL
  </verify>
  <done>SearchInput and ProductFilters update URL state via nuqs, values persist on refresh</done>
</task>

<task type="auto">
  <name>Task 2: Create ProductGrid and Pagination components</name>
  <files>
    apps/web/src/components/product/ProductGrid.tsx
    apps/web/src/components/product/Pagination.tsx
    apps/web/src/messages/hu.json
  </files>
  <action>
**Create ProductGrid.tsx (Server Component):**
```typescript
import { ProductCard } from './ProductCard';
import type { Product } from '@csz/types';

interface ProductGridProps {
  products: Product[];
}

export function ProductGrid({ products }: ProductGridProps) {
  if (products.length === 0) {
    return null; // Parent handles empty state
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {products.map((product) => (
        <ProductCard key={product.documentId} product={product} />
      ))}
    </div>
  );
}
```

**Create Pagination.tsx (Client Component):**
```typescript
'use client';

import { useQueryState, parseAsInteger } from 'nuqs';
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { useTranslations } from 'next-intl';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
}

export function Pagination({ currentPage, totalPages, totalItems }: PaginationProps) {
  const t = useTranslations('pagination');
  const [page, setPage] = useQueryState('page', parseAsInteger.withDefault(1).withOptions({
    shallow: false,
  }));

  if (totalPages <= 1) {
    return null;
  }

  const handlePrevious = () => {
    if (currentPage > 1) {
      setPage(currentPage - 1);
    }
  };

  const handleNext = () => {
    if (currentPage < totalPages) {
      setPage(currentPage + 1);
    }
  };

  return (
    <nav className="flex items-center justify-between py-8">
      <p className="text-sm text-muted-foreground">
        {t('showing', { page: currentPage, total: totalPages })}
      </p>
      <div className="flex gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={handlePrevious}
          disabled={currentPage <= 1}
        >
          <ChevronLeft className="h-4 w-4 mr-1" />
          {t('previous')}
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={handleNext}
          disabled={currentPage >= totalPages}
        >
          {t('next')}
          <ChevronRight className="h-4 w-4 ml-1" />
        </Button>
      </div>
    </nav>
  );
}
```

**Update hu.json:**
```json
{
  "pagination": {
    "previous": "Előző",
    "next": "Következő",
    "showing": "{page}. oldal / {total}"
  }
}
```

Add lucide-react icons if not already installed:
```bash
cd apps/web && pnpm add lucide-react
```
  </action>
  <verify>
1. ProductGrid renders products in responsive grid layout
2. 4 columns on xl, 3 on lg, 2 on sm, 1 on mobile
3. Pagination shows "1. oldal / 3" format
4. Previous button disabled on page 1
5. Clicking Next updates URL to ?page=2
  </verify>
  <done>ProductGrid displays responsive grid, Pagination controls page via URL state</done>
</task>

<task type="auto">
  <name>Task 3: Build product listing page with all components</name>
  <files>
    apps/web/src/app/[locale]/termekek/page.tsx
    apps/web/src/lib/api.ts
    apps/web/src/components/product/EmptyState.tsx
  </files>
  <action>
**Create EmptyState.tsx (Server Component):**
```typescript
import { useTranslations } from 'next-intl';
import { Package } from 'lucide-react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';

interface EmptyStateProps {
  hasFilters?: boolean;
}

export function EmptyState({ hasFilters }: EmptyStateProps) {
  const t = useTranslations('products');

  return (
    <div className="flex flex-col items-center justify-center py-16 text-center">
      <Package className="h-12 w-12 text-muted-foreground mb-4" />
      <h3 className="text-lg font-medium mb-2">{t('noResults')}</h3>
      {hasFilters && (
        <Link href="/termekek">
          <Button variant="outline" className="mt-4">
            {t('clearFilters')}
          </Button>
        </Link>
      )}
    </div>
  );
}
```

**Create /termekek/page.tsx:**
```typescript
import { Metadata } from 'next';
import { getProducts, getCategories } from '@/lib/api';
import { ProductGrid } from '@/components/product/ProductGrid';
import { ProductFilters } from '@/components/product/ProductFilters';
import { SearchInput } from '@/components/product/SearchInput';
import { Pagination } from '@/components/product/Pagination';
import { EmptyState } from '@/components/product/EmptyState';
import { getTranslations } from 'next-intl/server';

export async function generateMetadata(): Promise<Metadata> {
  const t = await getTranslations('products');
  return {
    title: t('title'),
    description: 'Böngésszen tűzvédelmi eszközök széles választékában',
  };
}

interface Props {
  searchParams: Promise<{
    category?: string;
    q?: string;
    page?: string;
  }>;
}

export default async function ProductsPage({ searchParams }: Props) {
  const params = await searchParams;
  const t = await getTranslations('products');

  // Fetch categories for filter dropdown
  const categoriesResponse = await getCategories();

  // Fetch products with filters
  const productsResponse = await getProducts({
    category: params.category,
    search: params.q,
    page: params.page ? parseInt(params.page, 10) : 1,
    pageSize: 12,
  });

  const { data: products, meta } = productsResponse;
  const { pagination } = meta;
  const hasFilters = !!(params.category || params.q);

  return (
    <main className="container mx-auto px-4 py-8">
      {/* Page header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold mb-2">{t('title')}</h1>
        {pagination && (
          <p className="text-muted-foreground">
            {t('showing', { count: pagination.total })}
          </p>
        )}
      </div>

      {/* Filters row */}
      <div className="flex flex-col sm:flex-row gap-4 mb-8">
        <div className="flex-1 max-w-md">
          <SearchInput />
        </div>
        <ProductFilters categories={categoriesResponse.data} />
      </div>

      {/* Product grid or empty state */}
      {products.length > 0 ? (
        <>
          <ProductGrid products={products} />
          {pagination && (
            <Pagination
              currentPage={pagination.page}
              totalPages={pagination.pageCount}
              totalItems={pagination.total}
            />
          )}
        </>
      ) : (
        <EmptyState hasFilters={hasFilters} />
      )}
    </main>
  );
}
```

**Ensure api.ts getProducts handles all filter cases:**
- category slug filter
- search (name containsi)
- page and pageSize
- Return empty array gracefully if API fails
  </action>
  <verify>
1. Start Strapi and add 2-3 products, 2 categories
2. Navigate to /termekek
3. Product grid shows all products
4. Type in search box - grid filters after 500ms, URL shows ?q=...
5. Select category from dropdown - grid filters, URL shows ?category=...
6. Combine search + category - both filters applied
7. Navigate to page 2 (if enough products) - URL shows ?page=2
8. Refresh page - filters persist from URL
9. "Szűrők törlése" button appears when filters active
  </verify>
  <done>Product listing page shows products, search/filter/pagination all work via URL state</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Navigate to /termekek
2. Page title "Termékek" displays
3. Search input accepts text and filters products after debounce
4. Category dropdown lists categories from Strapi
5. Selecting category filters product grid
6. Pagination shows and navigates between pages
7. URL reflects all filter state (?q=...&category=...&page=...)
8. Browser back/forward navigates filter history
9. Direct URL access with params shows correct filtered results
10. Empty state shows when no products match filters
</verification>

<success_criteria>
- Product listing page at /termekek renders product grid
- Search filters products by name (PROD-02)
- Category dropdown filters by category (PROD-01, PROD-03)
- Pagination works for large product sets
- All filter state managed via URL (nuqs)
- Page is responsive on all viewport sizes
- All UI text in Hungarian
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-shell/03-03-SUMMARY.md`
</output>
